// Lightweight Pascal IDE, process management unit// © Ingemar Ragnemalm 2006-2008// Some debugging stuff and comments in swedish remain. I will tidy that up some time.// Added feature 070913: Support for detecting prompts. That is, if the prompt arrives// with no CR (as in gdb, typical behavior for interactive programs) the prompt will// be sent to the data callback even though we have seen no CR.// Important bugfix 071014: Callbacks that start up new processes could write to// random memory!// Minor bugfix 07102x: ProcessLaunchToStringArr checks for buffer length correctly.// Revised 080321: removed pipe, use only pty, revised process termination checks// Revised 080330: Now use LittleLeopardReader, a layer to cope with the Leopard data loss bug.// Revised 080401: Overhaul of process termination.// 080509: System version check for the Leopard bug// 080511: The termios settings cause problems, at least under PPC/Tiger! We are back at defaults,// but this might need tweaking.// 080613: Termios now only set for Intel.// 090121: Added timeouts for ProcessLaunchSilent and ProcessLaunchToStringArr.// The timeout can be set with ProcessUtilsSetTimeout.// 150630: Moved ReadToPrompt to here{$mode macpas}unit ProcessUtils;interfaceuses	MacOSAll, cprocintf, termios, LittleLeopardReader, AlertsUtils, UtilsTypes;type	ProcessDataCallback = PROCEDURE(OneLineOfData: AnsiString; privateData: Pointer);	ProcessDoneProc = PROCEDURE(aborted: Boolean; exitStatus: Integer; privateData: Pointer);	PromptProc = PROCEDURE(privateData: Pointer);		ProcessRec = record		inChannel, outChannel: Longint;		pid: Longint;		inBuffer: AnsiString; // För att få data radvis.		pResult: cint; // Integer;		isRunning:  Boolean; {inspect through ProcessRunning to update}		lineByLineFlag: Boolean; {Default = true}				outDataCallback: ProcessDataCallback;		pad1: Str255;		doneCallback: ProcessDoneProc;		pad2: Str255;		privateData: Pointer;				timer: EventLoopTimerRef;		prompt: Str255;		promptCallback: PromptProc;	end;	ProcessPtr = ^ProcessRec;{Reading and writing from/to a process}procedure ProcessWrite(theProcess: ProcessPtr; s: AnsiString);procedure ProcessWriteLn(theProcess: ProcessPtr; s: AnsiString);function ProcessRead(theProcess: ProcessPtr): AnsiString;function ProcessReadLn(theProcess: ProcessPtr; var returnedLine: AnsiString): Boolean;{Process management}procedure ProcessSetCallbacks(theProcess: ProcessPtr; outDataCallback: ProcessDataCallback; doneCallback: ProcessDoneProc; privateData: Pointer);function ProcessLaunch(commandLine: AnsiString; internalTimer: Boolean): ProcessPtr;//function ProcessLaunch(commandLine: AnsiString): ProcessPtr;//function ProcessLaunch(appPath, appName: AnsiString): ProcessPtr;function ProcessRunning(theProcess: ProcessPtr): Boolean;function ProcessResult(theProcess: ProcessPtr): Integer;procedure ProcessTerminate(theProcess: ProcessPtr);procedure ProcessDispose(var theProcess: ProcessPtr);procedure ProcessSetLineBuffering(theProcess: ProcessPtr; lineByLineFlag: Boolean);procedure ProcessSetPrompt(theProcess: ProcessPtr; thePrompt: Str255; thePromptCallback: PromptProc);procedure ProcessPoll(theProcess: ProcessPtr); // Poll data using callbacks{Simplified calls for batch usage}procedure ProcessLaunchSilent(commandLine: AnsiString);//function ProcessLaunchToStringArr(commandLine: AnsiString): StringArr;procedure ProcessUtilsSetTimeout(secs: Longint); // Timeout for the two previous calls only.function ProcessToString(commandLine: AnsiString): AnsiString;function ProcessLaunchToStringArr(commandLine: AnsiString): StringArr;function ReadToPrompt(theProcess: ProcessPtr; command, prompt: AnsiString): AnsiString;const	kProcessUtilsFailedString = 'Failed!';	implementationprocedure ProcessWrite(theProcess: ProcessPtr; s: AnsiString);begin	write(theProcess^.outChannel, @s[1], Length(s));end;procedure ProcessWriteLn(theProcess: ProcessPtr; s: AnsiString);begin	s := s + char(10); // char(13)?	write(theProcess^.outChannel, @s[1], Length(s));end;procedure FinalTerminationCheck(theProcess: ProcessPtr; abort: Boolean);var	localDoneCallback: ProcessDoneProc;begin	if (not theProcess^.isRunning) and (Length(theProcess^.inBuffer) = 0) then	begin		if theProcess^.timer <> nil then		begin			RemoveEventLoopTimer(theProcess^.timer);			theProcess^.timer := nil;		end;		if theProcess^.doneCallback <> nil then		begin			localDoneCallback := theProcess^.doneCallback;			theProcess^.doneCallback := nil; // Once!			localDoneCallback(abort, theProcess^.pResult, theProcess^.privateData);// VIKTIGT! Vad händer om doneCallback avallokerar processen?// Pga detta måste doneCallback alltid köras SIST varefter man inte får använda theProcess!		end;//		else//			WriteLn('Terminated with no "done" callback');	end;end;procedure TerminationCheck(theProcess: ProcessPtr);begin	theProcess^.isRunning := waitpid(theProcess^.pid, theProcess^.pResult, WNOHANG) = 0; // theProcess^.pid if terminated, 0 if running;end;	function ProcessRead(theProcess: ProcessPtr): AnsiString;var	availableData, oldLength: Longint;begin// Read whatever is available	if theProcess^.isRunning then	begin		availableData := 1024;		oldLength := Length(theProcess^.inBuffer);			SetLength(theProcess^.inBuffer, oldLength + availableData);		availableData := read(theProcess^.inChannel, @theProcess^.inBuffer[oldLength+1], availableData);		if availableData > 0 then			SetLength(theProcess^.inBuffer, oldLength + availableData)		else			SetLength(theProcess^.inBuffer, oldLength);		// Vid läsning som ger noll (inte -1), kolla om processen är igång!		// Eller anta att den är avslutad!? Nej - det räcker inte.		if availableData = 0 then			TerminationCheck(theProcess);		if availableData = -1 then // Should test for EIO too!			if errno()^ = EIO then				TerminationCheck(theProcess);	end;	ProcessRead := theProcess^.inBuffer;	theProcess^.inBuffer := '';end;function ProcessReadLn(theProcess: ProcessPtr; var returnedLine: AnsiString): Boolean;var	i, availableData, oldLength: Longint;begin// Read new data, if any	if theProcess^.isRunning then	begin		availableData := 1024;		oldLength := Length(theProcess^.inBuffer);			SetLength(theProcess^.inBuffer, oldLength + availableData);		availableData := read(theProcess^.inChannel, @theProcess^.inBuffer[oldLength+1], availableData);//WriteLn('read returned ', availableData);		if availableData > 0 then			SetLength(theProcess^.inBuffer, oldLength + availableData)		else			SetLength(theProcess^.inBuffer, oldLength);		// Vid läsning som ger noll (inte -1), kolla om processen är igång!		// Eller anta att den är avslutad!?		if availableData = 0 then			TerminationCheck(theProcess);		if availableData = -1 then // Should test for EIO too!			if errno()^ = EIO then				TerminationCheck(theProcess);//			else // and maybe more?//				if errno^ <> EAGAIN then//					WriteLn('got error code ', errno()^);	end;//	else//	WriteLn('ProcessReadLn didnt read since process is dead');// Read up to CR/LF	for i := 1 to Length(theProcess^.inBuffer) do		if theProcess^.inBuffer[i] in [#10, #13] then		begin			ProcessReadLn := true;			returnedLine := Copy(theProcess^.inBuffer, 1, i-1);			Delete(theProcess^.inBuffer, 1, i);			// Rensa avslutande CRLF			if (Length(theProcess^.inBuffer) > 0) and (theProcess^.inBuffer[1] = #13) then				Delete(theProcess^.inBuffer, 1, 1);			if (Length(theProcess^.inBuffer) > 0) and (theProcess^.inBuffer[1] = #10) then				Delete(theProcess^.inBuffer, 1, 1);			Exit(ProcessReadLn);		end;	// If we get here, either we get no output or the process is terminated and we found no CR.	if not theProcess^.isRunning and (Length(theProcess^.inBuffer) > 0) then	begin		ProcessReadLn := true;		returnedLine := theProcess^.inBuffer;		theProcess^.inBuffer := '';//		FinalTerminationCheck(theProcess, false); // FARLIG HÄR!!! Kan jag garantera att den går fram?		Exit(ProcessReadLn);	end	else		ProcessReadLn := false;end;procedure ProcessSetCallbacks(theProcess: ProcessPtr; outDataCallback: ProcessDataCallback; doneCallback: ProcessDoneProc; privateData: Pointer);begin	if theProcess <> nil then	begin		theProcess^.privateData := privateData;		theProcess^.outDataCallback := outDataCallback;		theProcess^.doneCallback := doneCallback;		// TEST - catch fast replies		if outDataCallback <> nil then			ProcessPoll(theProcess);	end;end;function SetNoblock(fd: cint): cint;var	flags: cint;const {/usr/include/sys/fcntl.h}	O_NONBLOCK = $0004;		// no delay	F_GETFL = 3;		// get file status flags	F_SETFL = 4;		// set file status flagsbegin	// set file to non-blocking */	flags := fcntl(fd, F_GETFL, 0);	if fcntl(fd, F_SETFL, flags or O_NONBLOCK) <> 0 then		return -1;	return 0;end;type	ArgvType = array of pchar;var	args: array of AnsiString; {Unit-global to make it static}procedure CleanLiterals(var s: AnsiString);var	i: Longint;begin	for i := 1 to Length(s) do		if s[i] = '"' then			s := Copy(s, 1, i-1) + Copy(s, i+1, Length(s)-i);end;function BuildArgv(appName: AnsiString): ArgvType;var  argc, prev, i: Integer;  argv: ArgvType;  s: AnsiString;begin{Build arc/argv from command line}{To do: Add support for "\"?} argc := 0; prev := 0; i := 1; while i < Length(appName) do  begin   prev := i;   if appName[i] = ' ' then    i := i + 1   else if appName[i] = '"' then    begin{Scan to next " - full word}     i := i + 1; {Skip leading "}     prev := i;     while (appName[i] <> '"') and (i <= Length(appName)) do      i := i + 1;     s := Copy(appName, prev, i - prev);{Spara s?}	SetLength(args, argc+1);	SetLength(argv, argc+1);	args[argc] := s;	argv[argc] := @args[argc][1]; // PChar(@s[1]);	argc := argc + 1;	i := i + 1; {Skip end "}    end   else    begin{Scan to next space - full word}     while (appName[i] <> ' ') and (i <= Length(appName)) do     begin	       i := i + 1;{If "" after start, skip as part of the term}	       if appName[i] = '"' then	       begin		       i := i + 1;		       while (appName[i] <> '"') and (i <= Length(appName)) do		       i := i + 1;	       end;	end;     s := Copy(appName, prev, i - prev);	CleanLiterals(s);{Spara s?}	SetLength(args, argc+1);	SetLength(argv, argc+1);     args[argc] := s;     argv[argc] := PChar(@s[1]);     argc := argc + 1;    end;  end;	SetLength(argv, argc+1);	argv[argc] := nil;	return argv;end;function GetNameOnly (n: AnsiString): AnsiString;  var   i: Integer;begin  i := Length(n);// Strip off ending "/"  while (n[i] = '/') and (i > 1) do	begin		SetLength(n, Length(n)-1);		i := i - 1;	end;// Find last word  while (n[i] <> '/') and (i > 1) do   i := i - 1;  if i = 1 then   GetNameOnly := n  else   GetNameOnly := Copy(n, i + 1, Length(n) - i);end;procedure DoProcessTimer(theTimer: EventLoopTimerRef; userData: Pointer); MWPascal;begin	if userData <> nil then	begin//		WriteLn('BLÄNG!');		ProcessPoll(ProcessPtr(userData));	end	else		WriteLn('Timer with nil userData!!! *********');end;	{Copied from FileNameUtils:}	{Klipp bort filnamnet}	procedure TrimLastToken(var s: AnsiString);	var		i: Longint;	begin		i := Length(s);		while i > 0 do		begin			if s[i] = '/' then			begin				SetLength(s, i-1);				Exit(TrimLastToken);			end;			i := i - 1;		end;	end;// Utilty function that can be moved to some reusable code moduleprocedure GetSystemVersion(var major, minor, bugfix: Integer);// Missing in FPCMacOSAll:const	gestaltSystemVersionMajor     = 'sys1'; //* The major system version number; in 10.4.17 this would be the decimal value 10 */	gestaltSystemVersionMinor     = 'sys2'; //* The minor system version number; in 10.4.17 this would be the decimal value 4 */	gestaltSystemVersionBugFix    = 'sys3'; //* The bug fix system version number; in 10.4.17 this would be the decimal value 17 */var	vers: Longint;	err: OSErr;begin	// Hope for 10.4 or better, check for gestaltSystemVersionMajor/Minor/Bugfix	err := Gestalt(gestaltSystemVersionMajor, vers);	major := vers;	if err = noErr then	begin		err := Gestalt(gestaltSystemVersionMinor, vers);		minor := vers;	end;	if err = noErr then	begin		err := Gestalt(gestaltSystemVersionBugfix, vers);		bugfix := vers;	end;	if err <> noErr then {Pre-10.4 must use gestaltSystemVersion}	begin		err := Gestalt(gestaltSystemVersion, vers);		major := (vers SHR 8) and $ff;		minor := (vers SHR 4) and $f;		bugfix := vers and $f;	end;end;var	systemVersion: record		major, minor, bugfix: Integer;	end;function ProcessLaunch(commandLine: AnsiString; internalTimer: Boolean): ProcessPtr;//function ProcessLaunch(appPath, appName: AnsiString): ProcessPtr;var	str: AnsiString;	pid: Longint;//	status: Longint;	theProcess: ProcessPtr;	fd: Longint;//	err: Integer;	argv: ArgvType;//	name: AnsiString;	appPath, pathOnly: AnsiString;//	args: array[Word] of AnsiString;//	argc: Longint;//	i: Longint;	tail: AnsiString;	isBundle: Boolean;	juice: TermiosRec;const  testStr = 'Contents/MacOS';begin 	ProcessLaunch := nil;		if systemVersion.major = 0 then		GetSystemVersion(systemVersion.major, systemVersion.minor, systemVersion.bugfix);	//	WriteLn('PROCESS LAUNCH!!!');{Build arc/argv from command line}	argv := BuildArgv(commandLine);	appPath := argv[0];	argv[0] := PChar(GetNameOnly(argv[0]));		pathOnly := appPath;	TrimLastToken(pathOnly);//	WriteLn('Path:', appPath);//for i := 0 to Length(argv)-1 do//	WriteLn(i, '_:_', '<', argv[i], '>');{Check if it is a bundle! Then the string contains "Contents/MacOS" before the file name! Cut end off pathOnly! We must know this to know whether we should chdir or not.}	isBundle := false;	if Length(pathOnly) > Length(testStr) then	begin		tail := Copy(pathOnly, Length(pathOnly) - Length(testStr) + 1, Length(testStr));		isBundle := tail = testStr;	end;		pid := forkpty (@fd, nil, nil, nil);	case pid of	-1:		begin			WriteLn('can''t fork');			return nil;		end;	0 : { this is the code the child runs }		begin			if isBundle then				chdir(pathOnly);			//			execl(PChar(appPath), PChar(appName), nil); // Första parametern är med path. Men vilken är med parametrar? Den andra?			execv(PChar(appPath), @argv[0]);			str := kProcessUtilsFailedString + Char(10);			write(1, @str[1], Length(str));//			return nil;			//__exit(127);			Halt(127);// Argument?// Hur är det med PChar? Räcker @ för att den skall autokonvertera?		end;	otherwise { this is the code the parent runs}		begin//WriteLn('fork OK ');			SetNoblock(fd);	tcgetattr(fd, @juice);//	juice.c_lflag := juice.c_lflag and not (ECHO);//	juice.c_lflag := juice.c_lflag or (ECHOE or IEXTEN or ICANON or EXTPROC);	juice.c_lflag := juice.c_lflag and not (ECHO or ICANON or IEXTEN or ISIG);	juice.c_iflag := juice.c_iflag and not (BRKINT or ICRNL or INPCK or ISTRIP or IXON);	juice.c_cflag := juice.c_cflag and not (CSIZE or PARENB);	juice.c_cflag := juice.c_cflag or CS8;	juice.c_oflag := juice.c_oflag and not (OPOST);	juice.c_cc[VMIN] := char(1);	juice.c_cc[VTIME] := char(0);{$ifc defined CPUI386}// Only for Intel, PPC locks up - bug in termios definitions?	tcsetattr(fd, 0, @juice);{$ENDC}			theProcess := ProcessPtr(NewPtrClear(SizeOf(ProcessRec)));			// To restore to not use LittleLeopardRunner (Tiger style), just set inChannel to fd!			if systemVersion.minor >= 5 then // Leopard			begin				theProcess^.inChannel := StartReader(fd);//				WriteLn('Leopard style data input');			end			else			begin				theProcess^.inChannel := fd;//				WriteLn('Tiger style data input');			end;			SetNoblock(theProcess^.inChannel);			theProcess^.outChannel := fd;			theProcess^.pid := pid;			theProcess^.pResult := 0;			theProcess^.isRunning := true;			theProcess^.lineByLineFlag := true;			theProcess^.inBuffer := '';			theProcess^.prompt := '';			//WriteLn('Installing timer');			if internalTimer then				InstallEventLoopTimer (GetMainEventLoop(), kEventDurationSecond, kEventDurationSecond/10,							DoProcessTimer, Pointer(theProcess), theProcess^.timer)			else				theProcess^.timer := nil;//WriteLn('timer OK');						ProcessLaunch := theProcess;		end;	end; {case}end;// IMPORTANT// theProcess.isRunning refers only to the sub-process// ProcessRunning refers to whether or not the host should expect// more data, whether it is in the buffer or comes from the process.function ProcessRunning(theProcess: ProcessPtr): Boolean;begin	if theProcess = nil then		Return false;// Får enbart anropa waitpid efter läsning som inte returnerar något!//	if theProcess^.isRunning then//		theProcess^.isRunning := waitpid(theProcess^.pid, theProcess^.pResult, WNOHANG) = 0; // theProcess^.pid if terminated, 0 if running;//	TerminationCheck(theProcess);	ProcessRunning := theProcess^.isRunning or (Length(theProcess^.inBuffer) > 0);// Meningslöst här?		if not theProcess^.isRunning then		FinalTerminationCheck(theProcess, false);end;function ProcessResult(theProcess: ProcessPtr): Integer;begin	if theProcess = nil then		return -1;// OBS att detta kan avsluta en zombieprocess!//	if theProcess^.isRunning then//		TerminationCheck(theProcess);	ProcessResult := theProcess^.pResult;			FinalTerminationCheck(theProcess, false); // Callbacks!end;procedure ProcessTerminate(theProcess: ProcessPtr);var	pid: Longint;begin	if theProcess = nil then		Exit(ProcessTerminate);	pid := kill(theProcess^.pid, SIGTERM);	if pid = 0 then	begin		TerminationCheck(theProcess);//		theProcess^.isRunning := waitpid(theProcess^.pid, theProcess^.pResult, WNOHANG) = 0; // theProcess^.pid if terminated, 0 if running			if theProcess^.isRunning then		begin			pid := kill(theProcess^.pid, SIGKILL);			TerminationCheck(theProcess);		end;	end;	theProcess^.isRunning := false;	theProcess^.inBuffer := ''; // Nuke remaining data.//	WriteLn('Terminated, now calling callbacks, if any');	FinalTerminationCheck(theProcess, true);end;var	disposingThis: ProcessPtr;procedure ProcessDispose(var theProcess: ProcessPtr);begin	if disposingThis = nil then // Only terminate and dispose if we are not called by callback while doing it!	begin		disposingThis := theProcess;		if theProcess^.isRunning then			ProcessTerminate(theProcess);		DisposePtr(Ptr(theProcess)); // Farligt! Terminering kan avallokera!	end;	theProcess := nil;	disposingThis := nil;end;procedure ProcessSetLineBuffering(theProcess: ProcessPtr; lineByLineFlag: Boolean);begin	theProcess^.lineByLineFlag := lineByLineFlag;end;procedure ProcessSetPrompt(theProcess: ProcessPtr; thePrompt: Str255; thePromptCallback: PromptProc);begin	theProcess^.prompt := thePrompt;	theProcess^.promptCallback := thePromptCallback;end;procedure ProcessPoll(theProcess: ProcessPtr);var	myString: AnsiString;	loops: Longint;	gotSomething: Boolean;//	localDoneCallback: ProcessDoneProc;const	kLoopLimit = 5;begin	if theProcess = nil then		Exit(ProcessPoll);//WriteLn('Done callback ', HexStr(theProcess^.doneCallback));		loops := 0;		while true do	begin//WriteLn('Process polling data');		if theProcess^.lineByLineFlag then		begin			//WriteLn('polling ProcessReadLn');			gotSomething := ProcessReadLn(theProcess, myString);		end		else		begin			//WriteLn('polling ProcessRead');			myString := ProcessRead(theProcess);			gotSomething := Length(myString) > 0;		end;				if gotSomething then		begin// Handle output by callback//WriteLn('Got something: ***', myString, '***');			if theProcess^.outDataCallback <> nil then				theProcess^.outDataCallback(myString, theProcess^.privateData);		end		else // got nothing		begin//WriteLn('Talking loud but say nothing');			// Detect prompt if no new data arrived			if theProcess^.prompt <> '' then			begin				if theProcess^.inBuffer = theProcess^.prompt then				begin					if theProcess^.promptCallback <> nil then						theProcess^.promptCallback(theProcess^.privateData)					else						if theProcess^.outDataCallback <> nil then							theProcess^.outDataCallback(theProcess^.prompt, theProcess^.privateData);					theProcess^.inBuffer := '';				end;			end;						// Leave the polling loop, no more data for the moment			FinalTerminationCheck(theProcess, false);			Exit(ProcessPoll);		end;		// Don't stay indefinitely!		loops := loops + 1;		if loops > kLoopLimit then		begin			Exit(ProcessPoll);		end;	end;end; // ProcessPoll// Internal copy of an AlertUtils functionprocedure MessageAlert(msg, expl: AnsiString); overload;var	msgCFStr, explCFStr: CFStringRef;	theDialog: DialogPtr;	itemHit: DialogItemIndex; begin	// Konvertera till CFString, anropa andra, avallokera CFStrings	msgCFStr := CFStringCreateWithBytes(nil, @msg[1], Length(msg), kCFStringEncodingMacRoman, false);	if Length(expl) > 0 then		explCFStr := CFStringCreateWithBytes(nil, @expl[1], Length(expl), kCFStringEncodingMacRoman, false)	else		explCFStr := nil;	CreateStandardAlert(kAlertCautionAlert, msgCFStr, explCFStr, nil, theDialog);	RunStandardAlert(theDialog, nil, itemHit);	CFRelease(msgCFStr);	if explCFStr <> nil then		CFRelease(explCFStr);end;var	gTimeout: Longint = 5;//procedure ProcessLaunchSilent(appPath, appName: AnsiString);procedure ProcessLaunchSilent(commandLine: AnsiString);var	theProcess: ProcessPtr;//	s: AnsiString;	startTime: Longint;	timeout: Boolean;begin	theProcess := ProcessLaunch(commandLine, false);	if theProcess = nil then // Felkoll 090403	begin		MessageAlert('WARNING! ', commandLine + ' failed!');		Exit(ProcessLaunchSilent);	end;	startTime := time(nil);	repeat		{s :=} ProcessRead(theProcess);		// en gnutta usleep?		timeout := time(nil) - gTimeout > startTime;	until not ProcessRunning(theProcess) or timeout;	if timeout then		MessageAlert('WARNING! Timeout in ', commandLine);//		WriteLn('WARNING! Timeout in ', commandLine);	ProcessDispose(theProcess);// Maximum time? Callback?end;//function ProcessLaunchToStringArr(appPath, appName: AnsiString): StringArr;function ProcessLaunchToStringArrOLD(commandLine: AnsiString): StringArr;var	theProcess: ProcessPtr;	theStrings: StringArr;	s: AnsiString;	startTime: Longint;	timeout: Boolean;begin	SetLength(theStrings, 0);	theProcess := ProcessLaunch(commandLine, false);	if theProcess = nil then // Felkoll 090403	begin		MessageAlert('WARNING! ', commandLine + ' failed!');		return theStrings;	end;	startTime := time(nil);	repeat		if ProcessReadLn(theProcess, s) then		begin			SetLength(theStrings, Length(theStrings)+1);			theStrings[Length(theStrings)-1] := s;		end; // else usleep med långsamt ökande värde?		timeout := time(nil) - gTimeout > startTime;	until not ProcessRunning(theProcess) and (Length(theProcess^.inBuffer) = 0) or timeout;	if timeout then		MessageAlert('WARNING! Timeout in ', commandLine);//		WriteLn('WARNING! Timeout in ', commandLine);// Maximum time? Callback?	ProcessDispose(theProcess);	ProcessLaunchToStringArrOLD := theStrings;end;procedure ProcessUtilsSetTimeout(secs: Longint);begin	gTimeout := secs;end;// Copied from the newer PUfunction ProcessToString(commandLine: AnsiString): AnsiString;var		pid: cint;	pipe_fd: array [0..1] of cint;	prog1_argv: ArgvType; // array of PChar;	data, output: AnsiString;	availableData: Longint;	flags: cint;	pResult: cint;	running: Boolean;	startTime: Longint;	procedure PollInputData;	begin		repeat			SetLength(data, 1024);			availableData := read(pipe_fd[0], @data[1], Length(data));			if availableData > 0 then			begin				SetLength(data, availableData);				output := output + data;			end;		until availableData <= 0;	end;begin// Build argument list	prog1_argv := BuildArgv(commandLine);	// Create the pipe	if pipe(pipe_fd) < 0 then	begin		WriteLn ('pipe failed');		ProcessToString := '';		Exit(ProcessToString);		// or Exit('');	end;// Create a process space for the ls		pid := fork;	if pid < 0 then	begin		WriteLn ('Fork failed');		ProcessToString := '';		Exit(ProcessToString);//		Exit('');	end;	if pid = 0 then	begin// Set stdout to pipe 		dup2 (pipe_fd[1], 1);		dup2(pipe_fd[1], 2); // NEW 150118 - stderr. (Is this desirable?)// Close input end of pipe		close (pipe_fd[0]);		// Execute the given command		execvp (prog1_argv[0], @prog1_argv[0]);//		fpexecvp (prog1_argv[0], @prog1_argv[0]);		Halt(0);	end;	(* This is the parent *)	close(pipe_fd[1]); // Close output end of pipe		// Set to nonblocking to allow timeouts	flags := fcntl(pipe_fd[0], F_GETFL, 0);	if fcntl(pipe_fd[0], F_SETFL, flags or O_NONBLOCK) <> 0 then ;		// Read until the process ends	availableData := 0;	running := true;	startTime := time(nil); // In seconds!	output := '';	repeat		PollInputData;				if time(nil) > startTime + gTimeout then		if YesNoQuestionAlert('Process seems to hang. Continue?', 'Maybe it is just taking a long time with no output.') then			startTime := time(nil) // In seconds!		else		begin			WriteLn('Killing dead process. Do I commit suicide?');			pid := kill(pid, SIGTERM);//			pid := fpkill(pid, SIGKILL); Why does this kill the parent process instead of the child?		end;		running := waitpid(pid, pResult, WNOHANG) = 0;		if running then usleep(100); // Reduce CPU load from polling	until not running;// Read once more just in case	PollInputData;	usleep(10000); // Wait 10 ms for cleanup	PollInputData;		close(pipe_fd[0]); // Close input	ProcessToString := output;	// exit(output);end;function ProcessLaunchToStringArr(commandLine: AnsiString): StringArr;var	s, s1: AnsiString;	arr: StringArr;	i, start: Longint;const	CR = Char(13);	LF = Char(10);begin	s := ProcessToString(commandLine);	start := 1;	for i := 1 to Length(s) do	begin		if s[i] in [CR, LF] then		begin			s1 := Copy(s, start, i-start);			if Length(s1) > 0 then			begin				SetLength(arr, Length(arr)+1);				arr[High(arr)] := s1;			end;			start := i + 1;		end;	end;	ProcessLaunchToStringArr := arr;end;function ReadToPrompt(theProcess: ProcessPtr; command, prompt: AnsiString): AnsiString;var	s, s1: AnsiString;	startTime: Longint;const	kTimeout = 5; // 5 seconds timeoutbegin	startTime := time(nil);		// Get junk	//writeln('A');	s := ProcessRead(theProcess);	if Length(s) > 0 then		WriteLn('***ReadToPrompt old junk: ', s, '***');	if command <> '' then		s := ''; // avoided for empty command in case the prompt has already arrived	if command <> '' then		ProcessWrite(theProcess, command + Char(10));	writeln('command: ', command);	repeat		//writeln('B');		s1 := ProcessRead(theProcess);		//writeln('s1: ', s1, ' Length od s1: ', Length(s1));		if Length(s1) > 0 then			startTime := time(nil);		s := s + s1;	until (Copy(s, Length(s) - Length(prompt) + 1, Length(prompt)) = prompt)		or not ProcessRunning(theProcess)		or (time(nil) - kTimeout > startTime);// Maximum time? Callback?	//writeln('S from ReadToPrompt: ', s);	ReadToPrompt := s;end;end.