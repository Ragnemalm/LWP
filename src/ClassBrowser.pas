unit ClassBrowser;interfaceuses	MacOSAll, TransSkel4, Scroller, QDCG, ClassParser, LWPEdit,	LWPGlobals, Halda, HaldaTypes;procedure CBShowWindow;implementation// Parser in ClassParser// User interfacevar	cbWindow: WindowPtr;	sd: ScrollDataPtr;	gClassList: ClassDataList;const	kBoxWidth = 100;procedure WindMouse(thePt: MacOSAll.Point; t: UInt32; mods: integer);beginend;procedure WindKey(ch: char; mods: integer);beginend;function GetClassDepthOfClass(i, depth: Longint): Longint;var	maxDepth, depthPlus, j: Longint;begin	maxDepth := depth;	if depth > 100 then	begin		GetClassDepthOfClass := maxDepth;		Exit(GetClassDepthOfClass);	end;	for j := 0 to High(gClassList[i].inheritingIndex) do	begin		depthPlus := GetClassDepthOfClass(gClassList[i].inheritingIndex[j], depth + 1);		if depthPlus > maxDepth then			maxDepth := depthPlus;	end;	GetClassDepthOfClass := maxDepth;end;function GetClassDepth: Longint;var	maxDepth, depth, i: Longint;begin	maxDepth := 0;	for i := 0 to High(gClassList) do	begin		if gClassList[i].inheritedTotal = 0 then // Om toppnivå (borde inkludera alla som inte hittat några föräldrar i källkod)		begin			depth := GetClassDepthOfClass(i, 1);			if depth > maxDepth then				maxDepth := depth;		end;	end;	GetClassDepth := maxDepth;end;procedure AdjustSize;var	sum, i: Longint;	r: MacOSAll.Rect;	windBounds: MacOSAll.Rect;	depth: Longint;begin	// Set size!	sum := 1;	for i := 0 to High(gClassList) do	if gClassList[i].inheritedTotal = 0 then // Om toppnivå (borde inkludera alla som inte hittat några föräldrar i källkod)	begin//		DrawClassBox(i, sum, 0);		sum += gClassList[i].inheritingTotal;				windBounds := GetWindowPortBounds(cbWindow, windBounds)^;		windBounds.top += 20;		GetControlBounds(sd^.contentView, r);		// Set size to fit all data!		depth := GetClassDepth;		//WriteLn('Depth = ', depth);		r.right := windBounds.left + kBoxWidth * depth + 20; // Should reflect depth!//		r.right := windBounds.right; // Should reflect depth!		r.bottom := r.top + 20 * sum; // 		SetControlBounds(sd^.contentView, r);	end;end;procedure WindUpdate (resized: Boolean);var	windBounds: MacOSAll.Rect;	r: MacOSAll.Rect;	viewPort: MacOSAll.GrafPtr;	cgc: CGContextRef;begin	if resized then	begin		windBounds := GetWindowPortBounds(cbWindow, windBounds)^;//		SetRect(r, windBounds.left, windBounds.top, windBounds.right, windBounds.bottom);		windBounds.top += 20;		ResizeScroller(sd, windBounds);				AdjustSize;	end;end;procedure WindActivate (active: Boolean);begin	gClassList := GetProjectClassList; 		AdjustSize;end;procedure DoClose;begin	HideWindow(cbWindow);end;procedure WindHalt;beginend;procedure DrawView(theView: HIViewRef; cgContext: CGContextRef; cgviewRect: CGRect; userData: Pointer);var	viewRect, r: Rect;	i, j: Longint;	s: String;	function DrawClassBox(i, sum, depth: Longint): Real;	var		x, j: Longint;		r: Rect;		pos, minpos, maxpos, l: Real;		n: AnsiString;	begin		x := gClassList[i].inheritingTotal;		if x = 0 then x := 1;				MoveTo(10+depth*kBoxWidth, (sum + x/2-0.5)*20+20-5);		l := StringWidth(gClassList[i].className);		n := gClassList[i].className;		if l < kBoxWidth-10 then			Move((kBoxWidth-10 - l) / 2, 0)		else		begin			// Shorten string!			repeat				n := Copy(n, 1, Length(n)-1);			until StringWidth(n) < kBoxWidth-10;		end;//		DrawString(gClassList[i].className);		DrawString(n);		SetRect(r, 10+depth*kBoxWidth, (sum + x/2-0.5)*20+2, kBoxWidth+depth*kBoxWidth, (sum + x/2-0.5)*20+20-2);		FrameRect(r);		DrawClassBox := (r.top + r.bottom) / 2; // Return position of box		gClassList[i].locationInView := r; // Save location for mouse events		if depth > 0 then		begin			MoveTo(r.left, (r.top + r.bottom) / 2);			Line(-5, 0);		end;				if Length(gClassList[i].inheritingIndex) > 0 then		begin			MoveTo(r.right, (r.top + r.bottom) / 2);			Line(5, 0);			for j := 0 to High(gClassList[i].inheritingIndex) do			begin				pos := DrawClassBox(gClassList[i].inheritingIndex[j], sum, depth+1);				sum += gClassList[gClassList[i].inheritingIndex[j]].inheritingTotal;				if j = 0 then				begin					maxpos := pos;					minpos := pos;				end				else				begin					if pos > maxpos then maxpos := pos;					if pos < minpos then minpos := pos;				end;			end;			MoveTo(r.right + 5, minpos);			LineTo(r.right + 5, maxpos);		end;			end;var	sum: Longint;begin	viewRect := CGRectToRect(cgviewRect);//	UseViewContext(cgContext, cgviewRect.size.height);	CreatePort(cgContext, cgviewRect.size.height);	BackColor(whiteColor);	EraseRect(viewRect);		TextSize(10);	ForeColor(BlackColor);	PenSize(1);	sum := 1;	for i := 0 to High(gClassList) do	if gClassList[i].inheritedTotal = 0 then // Om toppnivå (borde inkludera alla som inte hittat några föräldrar i källkod)	begin		DrawClassBox(i, sum, 0);		sum += gClassList[i].inheritingTotal;	end;(*			for i := 0 to High(gClassList) do	begin		MoveTo(10, i*20+20 + 200);		DrawString(gClassList[i].className);		if Length(gClassList[i].inheritedClasses) > 0 then			DrawString(' inherits ')		else			DrawString(' ');		for j := 0 to High(gClassList[i].inheritedClasses) do		begin			DrawString(gClassList[i].inheritedClasses[j] + ' ');		end;		for j := 0 to High(gClassList[i].methods) do			DrawString(gClassList[i].methods[j].name + '/');		Str(gClassList[i].inheritingTotal, s);		DrawString(' Tup=' + s);		Str(gClassList[i].inheritedTotal, s);		DrawString(' Tdown=' + s);	end;*)	if High(gClassList) < 0 then	begin		MoveTo(10, 15 + 200); DrawString('No classes found in project');	end;	FinishPort;end;procedure MouseView(theView: HIViewRef; where: HIPoint; mods, button: Longint; userData: Pointer);const	kPathMenuID = 2001; // Whatevervar	front: WindowPtr;//	theSpec: FSSpecString;	fileData: AnsiString;	err: OSErr;	i, j: Longint;	methodsMenu: MenuRef;	menuSelection, item: Longint;	p: MacOSAll.Point;	editIndex: Longint;begin	if Length(gClassList)>0 then	for i := low(gClassList) to High(gClassList) do	begin		if PtInRect(where, gClassList[i].locationInView) then		begin			WriteLn('Hit ', i, ' = ', gClassList[i].className);			//writeln('BitAnd(mods, optionKey): ', BitAnd(mods, optionKey));			//writeln('Length(gClassList[i].methods): ', Length(gClassList[i].methods));						if BitAnd(mods, optionKey) <> 0 then			begin				// Go to class definition				editIndex := FindOrOpen(gClassList[i].definedInFilePath, gLastMainFile);				HSetSelection(teEdit[editIndex], gClassList[i].definedInFilePosition, gClassList[i].definedInFilePosition + Length(gClassList[i].className));				HShowSelection(teEdit[editIndex], true);//				HShowSelection(teEdit[editIndex]^.views[teEdit[editIndex]^.focusedView], true);				UpdateLineNumber(editWind[editIndex]);			end			else			if Length(gClassList[i].methods) > 0 then			begin				methodsMenu := NewMenu(kPathMenuID, ''); // Vilket ID???				if methodsMenu = nil then					Exit;								for j := 0 to High(gClassList[i].methods) do				begin					AppendMenu(methodsMenu, gClassList[i].methods[j].name);				end;				//WriteLn('Created menu');				InsertMenu(methodsMenu, -1);				//WriteLn('Inserted menu');// Position must be transformed to global coords//				menuSelection := PopUpMenuSelect(methodsMenu, Trunc(where.y), Trunc(where.x), 0);								where.x := gClassList[i].locationInView.right;				where.y := gClassList[i].locationInView.top;				HIPointConvert(where, kHICoordSpaceView, theView, kHICoordSpace72DPIGlobal, nil);//				p.h := Trunc(gClassList[i].locationInView.left);//				p.v := Trunc(gClassList[i].locationInView.top);				p.h := Trunc(where.x);				p.v := Trunc(where.y);//				LocalToGlobal(p);//				menuSelection := PopUpMenuSelect(methodsMenu, Trunc(gClassList[i].locationInView.left), Trunc(gClassList[i].locationInView.top), 0);				menuSelection := PopUpMenuSelect(methodsMenu, p.v, p.h, 0);				item := Lo(menuSelection);				//WriteLn('Selected ', item);				//WriteLn('Selected ', gClassList[i].methods[item-1].name);								if item > 0 then				begin					editIndex := FindOrOpen(gClassList[i].methods[item-1].fileName, gLastMainFile);	// GetFrontMainWindow					//writeln('editIndex: ', editIndex);					//writeln('Length(gClassList[i].methods): ', Length(gClassList[i].methods));					if Length(gClassList[i].methods)>0 then					begin						//writeln('fileName: ', gClassList[i].methods[item-1].fileName);						//writeln('name: ', gClassList[i].methods[item-1].name);						//writeln('class name: ', gClassList[i].methods[item-1].className);						//writeln('position: ', gClassList[i].methods[item-1].position);						HSetSelection(teEdit[editIndex], gClassList[i].methods[item-1].position, gClassList[i].methods[item-1].position + Length(gClassList[i].methods[item-1].name) {+ Length(gClassList[i].methods[item-1].className)} + 1);					end;															//HSetSelection(teEdit[editIndex], gClassList[i].definedInFilePosition, gClassList[i].definedInFilePosition + Length(gClassList[i].className));					HShowSelection(teEdit[editIndex], true);					UpdateLineNumber(editWind[editIndex]);				end;								//WriteLn('I now want to delete the menu');				DeleteMenu(kPathMenuID); // kPathMenuID eller nåt sånt				//WriteLn('Deleted menu');				DisposeMenu(methodsMenu);				//WriteLn('Disposed menu');				Exit;			end; // if it has methods		end; // if in rect	end; // for//	front := GetFrontMainWindow;//	err := GetEditFSSpec(front, theSpec);//	WriteLn('Front = ', theSpec);end;procedure KeyView(theView: HIViewRef; key: Char; mods: Longint; userData: Pointer);beginend;procedure InitCBWindow;var	r, mainFrame: MacOSAll.Rect;	err: OSStatus;	hv, masterView: ControlRef;begin	SetRect(r, 300, 80, 1000, 500);	err := CreateNewWindow ( kDocumentWindowClass, kWindowStandardDocumentAttributes, r, cbWindow);	SetWTitle(cbWindow, 'Class Browser');	ShowWindow(cbWindow);	SetPortWindowPort(cbWindow);		hv := HIViewGetRoot(cbWindow);	GetControlBounds(hv, mainFrame);	mainFrame.top += 20;	mainFrame.bottom -= 20;	CreateUserPaneControl(cbWindow, mainFrame, kControlSupportsEmbedding, masterView); // Top view, connects to parent	mainFrame.bottom := mainFrame.top + 700; // ???	sd := EmbedInScroller(hv, masterView, true, true, true, mainFrame);		InstallSkelViewHandler(cbWindow, sd^.contentView, @DrawView, @MouseView, @KeyView, nil);	SkelWindow(cbWindow, @WindMouse, @WindKey, @WindUpdate, @WindActivate, @DoClose, @WindHalt, nil, false);end;procedure CBShowWindow;begin	WriteLn('Show class browser selected');	if cbWindow = nil then		InitCBWindow;	ShowWindow(cbWindow);	SelectWindow(cbWindow);end;end.