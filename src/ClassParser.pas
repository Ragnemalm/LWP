{$mode objfpc}{ $modeswitch objectivec1}{ $mode objfpc}unit ClassParser;interfaceuses		MacOSAll, TransSkel4, Scroller, QDCG;type	MethodRec = record		className: AnsiString;		name: AnsiString;		position: Longint;		fileName: AnsiString;	end;		ClassDataRec = record		className: AnsiString;		inheritedClasses: array of AnsiString;		classScope:AnsiString;		//		inheritingClasses: array of AnsiString;		inheritedIndex: array of Longint;		inheritedTotal: Longint; // Hur mŒnga arv har identifierats?		inheritingIndex: array of Longint;		inheritingTotal: Longint; // Total number of classes inheriting this		locationInView: Rect; // Where was it drawn? Set by the DrawClassBox function.		methods: array of MethodRec;		definedInFileName, definedInFilePath: AnsiString; // Title or path?		definedInFilePosition: Longint; // So we can go there!		// More data?		// Parse methods?	end;	ClassDataList = array of ClassDataRec;function GetProjectClassList: ClassDataList;		implementationuses		ColorCoding, UtilsTypes, FileUtils, LWPEdit, IncludeAnalyzer, LWPGlobals, ClosedFilesDataManager;// COPIED FROM ColorCoding.pas!// Fix for stupid error caused by old Toolbox functions.// LowerCaseText doesn't work above 16k!// Note: For strings there is a "LowerCase" call.procedure MyLowerCaseText(pt: Ptr; dataSize: Longint; ignored: Integer);var	i, s: Longint;	p: CharsPtr;begin	p := CharsPtr(pt);	s := dataSize-1;	for i := 0 to s do		if p^[i] in ['A'..'Z'] then			p^[i] := Char(Ord(p^[i]) + 32);end;var	gMethods: array of MethodRec;function ParseClassesFromText(data: AnsiString; bufferLength: Longint; theTitle, theSpec: AnsiString): ClassDataList;var	//		err: OSErr;	pos, tokenStart, tokenEnd, tokenType: Longint;	tokenValue, lowerCaseTokenValue, prev2TokenValue, prevTokenValue: AnsiString;	className, methodName, procedureName: AnsiString;	prevStart, prevEnd, prev2Start, prev2End: Longint;	//		extension: Str255;	//		cleanName: Str255; // Fšr C-delen	extType: Integer;		list: ClassDataList;	dataCopy: AnsiString;	i: Longint;	c: Char;begin	SetLength(list, 0);	pos := 0;	prevTokenValue := '';	prev2TokenValue := '';	prevStart := 0;	prevEnd := 0;	prev2Start := 0;	prev2End := 0;	tokenType := -1; // none			// Inspect file extension.		extType := GetExtensionType(theTitle);	if extType = kExtTypePascal then	begin		// Must have a copy in lower case to parse!				dataCopy := LowerCase(data);		// Simple Pascal parsing looking for "class"				repeat			// Read tokens throughout the file.									// Shift back old values 2 steps - but not if the last was a comment!						if not (tokenType in [kCommentToken, kCompilerDirectiveToken]) then			begin				prev2TokenValue := prevTokenValue;				prev2Start := prevStart;				prev2End := prevEnd;								prevTokenValue := tokenValue;				prevStart := tokenStart;				prevEnd := tokenEnd;			end;						GetToken(dataCopy, bufferLength, pos, tokenStart, tokenEnd, tokenType, tokenValue);						if tokenType = kReservedToken then // Correct for all cases?			//			if tokenType = kClassToken then // Correct for all cases?						begin				if (tokenValue = 'object') or (tokenValue = 'class') or (tokenValue = 'objcclass') then // objcclass, class?				begin					//WriteLn('Found ', tokenValue);					// prev2TokenValue is the class name										// read on until we know more about it.										// It is probably followed by () around one inherited class										GetToken(dataCopy, bufferLength, pos, tokenStart, tokenEnd, tokenType, tokenValue);					//					WriteLn('Next token is ', tokenValue);										//					className := prev2TokenValue;										//					MoveBytes(@dataPtr^[prev2Start], @className[1], Length(className));										className := Copy(data, prev2Start, Length(className) + prev2Start+1); // NOT correct any more!										//					WriteLn('Class name in case = ', className);															//					WriteLn('Storing ', prev2TokenValue, ' to list');										SetLength(list, Length(list)+1);					list[High(list)].className := className;					SetLength(list[High(list)].inheritedClasses, 0); // No inherited classes found yet										list[High(list)].definedInFileName := theTitle;					list[High(list)].definedInFilePath := theSpec;					list[High(list)].definedInFilePosition := prev2Start; // tokenStart;										//					WriteLn('Done storing to list');										if tokenValue = '(' then					//					if tokenType = kStartParenToken then // Start of ( ) - read until kEndParenToken										// "object"/"class" found, parse for inheritance										begin						//						WriteLn('Parsing inheritance');												repeat							GetToken(dataCopy, bufferLength, pos, tokenStart, tokenEnd, tokenType, tokenValue);							if tokenType = kOtherToken then // Ej komma eller parentes. This is just made! 14=library token??? tobject predefined?							begin								//WriteLn('Found inherited token = ', tokenValue);																// Get value in case!																//MoveBytes(@dataPtr^[tokenStart], @tokenValue[1], Length(tokenValue));																tokenValue := Copy(data, tokenStart, tokenStart+Length(tokenValue)+1);								// Append findings to list.																SetLength(list[High(list)].inheritedClasses, Length(list[High(list)].inheritedClasses)+1); // No inherited classes found yet																list[High(list)].inheritedClasses[High(list[High(list)].inheritedClasses)] := tokenValue;								//								WriteLn(prev2TokenValue + ' inherits ', tokenValue);																							end;						until (pos >= bufferLength) or {(tokenType = kSingleCharToken) and}						(tokenValue = ')') or (tokenType = kEndParenToken);						// kEndParenToken, vŠl?											end					else						WriteLn('No inheritance found');										// Parse methods										// MUST also find method implementations!										// procedure/function followed by Class.Name!										// Same way as in the color coder?									end			end			else // if not kClassToken								if tokenType = kFunctionToken then				begin					//					WriteLn('Found function/procedure/method');										repeat						GetToken(dataCopy, bufferLength, pos, tokenStart, tokenEnd, tokenType, tokenValue);					until (pos >= bufferLength) or (tokenType = kOtherToken);					if tokenType = kOtherToken then // Most likely function name					begin						// Get token in case!												//						procedureName := tokenValue;												//						MoveBytes(@dataPtr^[tokenStart], @procedureName[1], Length(procedureName));												procedureName := Copy(data, tokenStart, tokenStart+tokenEnd+1);						//						WriteLn('Procedure name in case = ', procedureName);																		i := 0; // Check if name contains .												repeat							i += 1;							c := tokenValue[i];						until (i >= Length(tokenValue)) or (c = '.');						if c = '.' then						begin							//							WriteLn('Found method ', tokenValue);														className := Copy(procedureName, 1, i-1);							methodName := Copy(procedureName, i+1, Length(procedureName)-i);							//							WriteLn('Class name ', className);														//							WriteLn('Method name ', methodName);														// Gather all methods in one list, sort into classes later, since implementation and type might not be in the same file														SetLength(gMethods, Length(gMethods)+1);							gMethods[High(gMethods)].className := className;							gMethods[High(gMethods)].name := methodName;							gMethods[High(gMethods)].position := tokenStart;							gMethods[High(gMethods)].fileName := theSpec;						end;						//						else												//							WriteLn(tokenValue, ' is not a method');												end;				end;		until  pos >= bufferLength;		// Done!				//WriteLn('>>> ParseClassesFromText Done');				ParseClassesFromText := list;	end	else		if extType = kExtTypeCPP then		begin			// Similar, but using "GetCToken" and parsing for C++ style stuff					end;	// else if extType = kExtTypeJava then		// else if extType = kExtTypeObjC then			//ParseClassesFromText := list;	end; {GetUsesListFromText}operator + (a, b: ClassDataList) c: ClassDataList;var	i: Longint;begin	SetLength(c, Length(a) + Length(b));	for i := 0 to High(a) do		c[i] := a[i];	for i := 0 to High(b) do		c[i + Length(a)] := b[i];end;function GetProjectClassList: ClassDataList;var	total, arr: ClassDataList;	front: WindowRef;	err: OSErr;	theSpec: AnsiString;	theFileArr: AnsiStringArray; //FileArr;	i, j, k: Longint;	fileData: AnsiString;	flag: Boolean;	eIOpenFile: Boolean;		editIndex, editIndOpenFile:LongInt;	// How many inherits this?	// No - how much space should be reserved for this?	function CountChildren(i: Longint; start, depth: Longint): Longint;	var		j, sum: Longint;	const		kMaxInheritanceDepth = 20;	begin		sum := Length(total[i].inheritingIndex);		//		if depth < kMaxInheritanceDepth then // Guarantees a limit			for j := 0 to High(total[i].inheritingIndex) do			//				if start <> total[i].inheritedIndex[j] then // Try to avoid infinite loops. This checks for ones including the start.					sum := sum + CountChildren(total[i].inheritingIndex[j], start, depth+1);		if sum > 0 then 			sum := sum - 1; // Take off 1 for parent			CountChildren := sum;	end;begin	//WriteLn('>>> Entering GetProjectClassList!');	// Get main window and its spec		front := GetFrontMainWindow;	editIndex := getWRefCon(front);	if front = nil then	begin		GetProjectClassList := nil; // No project!				Exit(GetProjectClassList);	end;	err := GetEditFSSpec(front, theSpec);	//WriteLn('>>> GetProjectClassList has the spec');		if editIndex > 0 then		if editIndex <= kMaxEditWindows then			theFileArr := BuildJTFNUsesList(editWind[editIndex], true );		//theFileArr := GetIncludeFileList(theSpec, true {include header files});		SetLength(theFileArr, Length(theFileArr)+1);	for i := High(theFileArr)-1 downto 0 do		theFileArr[i+1] := theFileArr[i];	theFileArr[0] := theSpec;			//writeln('Length of files: ', Length(theFileArr));	//for i := Low(theFileArr) to High(theFileArr) do		//writeln('theFileArr: ', theFileArr[i]);				//If the file is open, then get classList using corresponding editIndex, else 		//get classList using closedClassList.		for i := 0 to High(theFileArr) do // Should only re-parse changed files! Clean list of all old data, re-parse selected files.		begin		editIndOpenFile := FileIsOpen(theFileArr[i]); //If the file is open then it returns it's editIndex.				//writeln('eIOpenFile: ', editIndOpenFile);		//writeln('list ', i, ': ', list[i]);				if editIndOpenFile > 0 then		begin			//SetLength(total, Length(total)+1);						//total[High(total)] := editClassList[editIndOpenFile];			total:= total + editClassList[editIndOpenFile];						//It should search with filenames.			{for j:=0 to High(editClassList[editIndex]) do			begin				if(theFileArr[i] = editClassList[editIndex][j].definedInFilePath) then								end;}			//writeln('File opened is: ', theFileArr[i]);			//writeln('Length of editClassList: ', Length(editClassList[editIndOpenFile]));		end;		//else			//writeln('File is closed: ', theFileArr[i]);				end;		if (Length(closedFilesClassList[editIndex]) > 0) then		total:= total + closedFilesClassList[editIndex];		// Make an array of files including the main file		// IS THIS SPECS/PATHS OR FILE NAMES?		(*theFileArr := GetIncludeFileList(theSpec, true {include header files});	SetLength(theFileArr, Length(theFileArr)+1);	for i := High(theFileArr)-1 downto 0 do		theFileArr[i+1] := theFileArr[i];	theFileArr[0] := theSpec;	WriteLn('>>> GetProjectClassList has the include file list');		SetLength(total, 0);	SetLength(gMethods, 0); // Init method list	//If the file is open, then get classList using corresponding editIndex, else 	//get classList using closedClassList.	for i := 0 to High(theFileArr) do // Should only re-parse changed files! Clean list of all old data, re-parse selected files.	begin//		WriteLn('>>> GetProjectClassList reads ' + GetLastToken(theFileArr[i]));		//fileData := ReadFileToString(theFileArr[i], err);//		WriteLn('>>> ' + GetLastToken(theFileArr[i]) + ' is ', Length(fileData), ' bytes');				//arr := ParseClassesFromText(fileData, Length(fileData), GetLastToken(theFileArr[i]){title}, theFileArr[i]);//		WriteLn('>>> GetProjectClassList got ', Length(arr), ' classes from ' + GetLastToken(theFileArr[i]));//		WriteLn(Length(total), ',', Length(arr));//		for j := 0 to High(arr) do//			WriteLn(arr[j].className);//		for j := 0 to High(total) do//			WriteLn(total[j].className);(*		SetLength(total, Length(total) + Length(arr));		for j := 0 to High(arr) do		begin			WriteLn('Copy item ', j, ' to ', High(total)-High(arr) + j);			WriteLn(Length(total), ',', Length(arr));			WriteLn(arr[j].className);			total[High(total)-High(arr) + j] := arr[j]; CRASH		end;*)		//total := total + arr;		//		total := arr; // CRASH! Yes!		//	GetProjectClassList := arr; // CRASH - no?		//	end;*)			{for i := Low(list) to High(list) do			 writeln('list: ', list[i]);}			// Insert all methods into total	for i := 0 to High(theFileArr) do // Should only re-parse changed files! Clean list of all old data, re-parse selected files.		begin		editIndOpenFile := FileIsOpen(theFileArr[i]); //If the file is open then it returns it's editIndex.				//writeln('@#$eIOpenFile: ', editIndOpenFile);		//writeln('theFileArr[i]: ', theFileArr[i]);		//writeln('list ', i, ': ', list[i]);				if editIndOpenFile > 0 then		begin			//writeln('Length(editMethods[editIndex]): ', Length(editMethods[editIndex]));			if Length(editMethods[editIndex])>0 then				for j := 0 to High(editMethods[editIndex]) do				begin 					for k := 0 to High(total) do					begin 						//writeln(editMethods[editIndex][j].className, ' ',total[k].className );						if LowerCase(editMethods[editIndex][j].className) = LowerCase(total[k].className) then						begin 							SetLength(total[k].methods, Length(total[k].methods)+1);							total[k].methods[High(total[k].methods)] := editMethods[editIndex][j];							//writeln('total[k].methods[High(total[k].methods)]: ', editMethods[editIndex][j].name);						end; 					end; 				end; 		end; 		end; 		if Length(closedFilesMethods[editIndex])>0 then		begin			for j := 0 to High(closedFilesMethods[editIndex]) do				begin					for k := 0 to High(total) do					begin						//writeln(closedFilesMethods[editIndex][j].className, ' ',total[k].className );						if LowerCase(closedFilesMethods[editIndex][j].className) = LowerCase(total[k].className) then						begin							SetLength(total[k].methods, Length(total[k].methods)+1);							total[k].methods[High(total[k].methods)] := closedFilesMethods[editIndex][j];							//writeln('total[k].methods[High(total[k].methods)]: ', closedFilesMethods[editIndex][j].name);						end;					end;				end;					end;			{for i := 0 to High(gMethods) do	begin		for j := 0 to High(total) do		begin			if LowerCase(gMethods[i].className) = LowerCase(total[j].className) then			begin				SetLength(total[j].methods, Length(total[j].methods)+1);				total[j].methods[High(total[j].methods)] := gMethods[i];			end;		end;	end;}			//Clear inheritingIndex		for i := 0 to High(total) do // for all classes				SetLength(total[i].inheritingIndex, 0);		//writeln('Length of Total: ', Length(total));	// Create index references for inheritance		for i := 0 to High(total) do // for all classes that might inherit something		begin		SetLength(total[i].inheritedIndex, Length(total[i].inheritedClasses));		// Zero inheritedIndex? Unnecessary?				for j := 0 to High(total[i].inheritedIndex) do			total[i].inheritedIndex[j] := -1; // Not found yet				for k := 0 to High(total[i].inheritedClasses) do // for all that i inherits				begin			for j := 0 to High(total) do // for all classes it might inherit						begin				//writeln('total[i].inheritedClasses[k]: ', total[i].inheritedClasses[k]);				//writeln('total[j].className: ', total[j].className);				if total[i].inheritedClasses[k] = total[j].className then // i inherits from j				begin					total[i].inheritedIndex[k] := j; // i should know that it inherits j										SetLength(total[j].inheritingIndex, Length(total[j].inheritingIndex)+1);					total[j].inheritingIndex[High(total[j].inheritingIndex)] := i; // j should know that i inherits j									end;			end;		end;	end;		// Count number of children		// Wrong? Count space needed in class browser?		for i := 0 to High(total) do // for all classes		begin		total[i].inheritingTotal := CountChildren(i, i, 0) + 1; // 1 for root			end;		// Count number of INDENTIFIED peers (to see if this should count as root)		for i := 0 to High(total) do // for all classes		begin		total[i].inheritedTotal := 0;		for j := 0 to High(total[i].inheritedIndex) do			if total[i].inheritedIndex[j] >= 0 then				total[i].inheritedTotal+=1;	end;		GetProjectClassList := total;	//writeln('Length of GetProjectClassList: ', Length(GetProjectClassList));	{for i:=low(GetProjectClassList) to High(GetProjectClassList) do	begin		writeln('GetProjectClassList: ', GetProjectClassList[i].className); 	end;}	end;end.