// QDCG by Ingemar Ragnemalm 2009-2010// Pictures - CGImage and PDFs, including recording.// A PicHandle can be a CGImage or a one-page PDF// Multi-page PDFs are handled by...? New calls with page numbers!// 150403: GetPicture now returns nil if it fails// 20150901: DrawPicture (DrawPDFDocument) checks for nonexisting pages!// 20160209: Fixed a bug which surfaced under newer OSX. Works under FPC 3.0!{$mode objfpc}{$modeswitch objectivec1}unit QDCGPictUnit;interfaceuses//	cmem, ctypes, BaseUnix, MacOSAll, CocoaAll, QDCG; // MacOSAll included for CG	MacOSAll, CocoaAll, QDCG; // MacOSAll included for CG// Picture is defined in QDCG's main unitfunction OpenPicture(const (*var*) picFrame: Rect): PicHandle;procedure PictureNextPage; {For creating multi-page PDFs}procedure ClosePicture;procedure DrawPicture(image: PicHandle; r: Rect); overload;procedure DrawPicture(image: PicHandle; r: Rect; originH, originV: Real; angle: Real; page: Longint);overload; // Main callprocedure DrawPicture(image: PicHandle; r: Rect; origin: Point; angle: Real);overload;procedure DrawPicture(image: PicHandle; r: Rect; originH, originV: Real; angle: Real);overload;procedure DrawPicture(image: PicHandle; r: Rect; angle: Real);overload;procedure DrawPicture(image: PicHandle; r: Rect; origin: Point; angle: Real; page: Longint);overload;procedure DrawPicture(image: PicHandle; r: Rect; angle: Real; page: Longint);overload;// Variants without Rectprocedure DrawPicture(image: PicHandle; left, top, right, bottom: Real); overload;procedure DrawPicture(image: PicHandle; left, top, right, bottom, originH, originV, angle: Real; page: Longint);overload;procedure DrawPicture(image: PicHandle; left, top, right, bottom, originH, originV, angle: Real);overload;procedure DrawPicture(image: PicHandle; left, top, right, bottom: Real; origin: Point; angle: Real);overload;procedure DrawPicture(image: PicHandle; left, top, right, bottom, angle: Real);overload;procedure DrawPicture(image: PicHandle; left, top, right, bottom: Real; origin: Point; angle: Real; page: Longint);overload;procedure DrawPicture(image: PicHandle; left, top, right, bottom, angle: Real; page: Longint);overload;function CountPicturePages(image: PicHandle): Longint;function GetPicture(fileName: AnsiString): PicHandle;procedure KillPicture(var image: PicHandle);procedure QDGetPictureBounds(image: PicHandle; var bounds: Rect); overload;procedure QDGetPictureBounds(image: PicHandle; var bounds: Point); overload;function QDGetPictureBounds(image: PicHandle): Point; overload;type	ByteArray = {packed} array of Byte;function ReadDataFile(fileName: AnsiString): ByteArray;procedure WriteDataFile(fileName: AnsiString; data: ByteArray); overload;procedure WriteDataFile(fileName: AnsiString; dataPtr: Pointer; dataLength: Longint); overload;procedure WriteDataFile(fileName: AnsiString; dataRef: CFDataRef); overload;function LoadPDFPicture(fileName: AnsiString): PicHandle;procedure SavePDFPicture(ph: PicHandle; fileName: AnsiString);function LoadPDFPictureResource(fileName: AnsiString): PicHandle;procedure SavePDFPictureResource(ph: PicHandle; fileName: AnsiString);// LoadPDFPicture and LoadPDFPictureResource may be integrated with GetPicture.// Gworldsprocedure DisposeGWorld(offscreenGWorld: GWorldPtr);procedure CopyBits(src, dest: GrafPtr; srcRect, destRect: Rect {+ transfer mode});function NewGWorld(var offscreenGWorld: GWorldPtr; boundsRect: Rect): OSErr;implementationvar	pdfContext: CGContextRef;	gRecordingPict: PicHandle;	gPictRecordingData: CFMutableDataRef;	saveCtx: CGContextRef;	openPictureSavePort: GrafPtr;function OpenPicture(const (*var*) picFrame: Rect): PicHandle;var	consumer: CGDataConsumerRef;	mediaBox: CGRect;begin	mediaBox := RectToCGRect(picFrame);	gPictRecordingData := CFDataCreateMutable(nil, 0);	consumer := CGDataConsumerCreateWithCFData(gPictRecordingData);	pdfContext := CGPDFContextCreate(consumer, mediaBox, nil);	CGDataConsumerRelease(consumer); // The context retains the consumer, so we can safely release here// Start a page in the context	CGPDFContextBeginPage(pdfContext, nil);// This works... but is the PDF then in itself flipped or not?// Looks OK!	CGContextTranslateCTM(pdfContext, 0, picFrame.bottom - picFrame.top);	CGContextScaleCTM(pdfContext, 1, -1);		gRecordingPict := New(PicHandle);	gRecordingPict^.picFrame := picFrame;		gRecordingPict^.picImage := nil; // Must be nil	gRecordingPict^.picPDF := nil; // None yet	gRecordingPict^.picPDFDataRef := nil; // None yet//	gRecordingPict^.picPDFData := nil; // None yet//	gRecordingPict^.picPDFLength := 0; // None yet	OpenPicture := gRecordingPict;		// BUG FIX: Crashed here when called outside draw proc.//	if thePort <> nil then//	begin	openPictureSavePort := thePort;//		saveCtx := thePort^.ctx;//		thePort^.ctx := pdfContext;//	end//	else	begin		UseViewContext(pdfContext, mediaBox.size.height);		thePort^.temporaryPort := true; // Should be closed by ClosePicture so it should not matter//		saveCtx := nil;	end;end;procedure PictureNextPage;begin	CGPDFContextEndPage(thePort^.ctx);	CGPDFContextBeginPage(thePort^.ctx, nil);	CGContextTranslateCTM(pdfContext, 0, gRecordingPict^.picFrame.bottom - gRecordingPict^.picFrame.top);	CGContextScaleCTM(pdfContext, 1, -1);end;procedure ClosePicture;var	provider: CGDataProviderRef;//	dstr: AnsiString;	pdfref: CGPDFDocumentRef;begin	if saveCtx <> nil then		thePort^.ctx := saveCtx;	CGPDFContextEndPage(pdfContext);	CGContextRelease(pdfContext);	ClosePort(thePort);	SetPort(openPictureSavePort);	provider := CGDataProviderCreateWithCFData (gPictRecordingData);	pdfref := CGPDFDocumentCreateWithProvider(provider);//	CFRelease(gPictRecordingData);	//	gRecordingPict^.picFrame := picFrame;		gRecordingPict^.picImage := nil; // Must be nil	gRecordingPict^.picPDF := pdfref; // PDF reference - now it is done	gRecordingPict^.picPDFDataRef := gPictRecordingData; // Save data ref//	gRecordingPict^.picPDFData := nil; // GetMem(); // Save data//	gRecordingPict^.picPDFLength := 0; // and its lengthend;//type//	ByteArray = array of Byte;// Replace ReadDataFile by this:function ReadDataFile(fileName: AnsiString): ByteArray;//function ReadDataFile(pathSpec: AnsiString; var err: OSErr; var readOnlyFlag: Boolean): ByteArray;type//		CharFile = file of Char;	cint = Longint;	CharFile = file of Char;var	FD : CharFile;	data: ByteArray;	amount: cint;	err: OSErr;const	kMaxAmount = 1024;begin	SetLength(data, 0);//	readOnlyFlag := false; // How do I know?	assign(fd, fileName);	{$I-}	reset(fd);                   { open it without breaking for error }	{$I+}	if IOResult = 0 then	begin		repeat			SetLength(data, Length(data) + kMaxAmount);			BlockRead(fd, data[Length(data) - kMaxAmount + 0], kMaxAmount, amount);		until amount < kMaxAmount;		// Correct length for last step		if amount > 0 then			SetLength(data, Length(data) + amount - kMaxAmount) // Some read last time		else			SetLength(data, Length(data) - kMaxAmount); // Nothing read last time		Close(FD);	end;	err := IOResult;	ReadDataFile := data;end;(*// Remove in order to get rid of units causing crashes.function ReadDataFileOLD(fileName: AnsiString): ByteArray;var	FD : UInt32; // Cint;	data: ByteArray;	amount: UInt32; // cint;const	kMaxAmount = 1024;begin	SetLength(data, 0);	FD:=fpOpen (fileName, O_RDONLY);	if FD>0 then	begin		repeat			SetLength(data, Length(data) + kMaxAmount);			amount := fpRead (FD, data[Length(data) - kMaxAmount], kMaxAmount);		until amount < kMaxAmount;		// Correct length for last step		if amount > 0 then			SetLength(data, Length(data) + amount - kMaxAmount) // Some read last time		else			SetLength(data, Length(data) - kMaxAmount); // Nothing read last time (was +, must be wrong)		fpClose(FD);	end;	result := data;end;*)procedure WriteDataFile(fileName: AnsiString; data: ByteArray); overload;//	function WriteDataFile(pathSpec: AnsiString; theString: ByteArray): OSErr;	type		CharFile = file of Char;	var		fd : CharFile;		theResult: Int64; // ???		err: OSErr;	begin		assign(fd, fileName); // Can cause exception?		err := IOResult;		if err <> 0 then			WriteLn('FAIL in WriteStringToFile assign');		{$I-}		rewrite(fd);                   { open it without breaking for error }		{$I+}		if err = 0 then		begin			BlockWrite(fd, data[0], Length(data), theResult);			err := IOResult;			if err <> 0 then				WriteLn('FAIL in WriteStringToFile BlockWrite')			else				if theResult < 1 then					err := -1;	//		AppendLn(fd, theString);			Close(fd);		end;//		WriteDataFile := err;	end;(*procedure WriteDataFile(fileName: AnsiString; data: ByteArray); overload;var	FD : Cint;begin	WriteLn('Writing to ', fileName);	FD:=fpOpen (fileName, O_WrOnly or O_Creat);	if FD>0 then	begin		if length(data)<>fpwrite (FD,data[0],Length(data)) then			Writeln ('Error when writing to file !');		fpClose(FD);	end;end;*)procedure WriteDataFile(fileName: AnsiString; dataPtr: Pointer; dataLength: Longint); overload;var	data: ByteArray;begin	SetLength(data, dataLength);	System.Move(dataPtr^, data[0], dataLength);	WriteDataFile(fileName, data);end;procedure WriteDataFile(fileName: AnsiString; dataRef: CFDataRef); overload;var	data: ByteArray;	dataLength: Longint;begin	dataLength := CFDataGetLength(dataRef);	SetLength(data, dataLength);	CFDataGetBytes(dataRef, CFRangeMake(0, dataLength), @data[0]);	WriteDataFile(fileName, data);end;procedure SavePDFPicture(ph: PicHandle; fileName: AnsiString);begin// Save file by full path or current directory.	WriteDataFile(fileName, ph^.picPDFDataRef);end;procedure Home; // same as SkelHomeconst	PATH_MAX = 1024;var	mainBundle: CFBundleRef;	resourcesURL: CFURLRef;	path: AnsiString;//	err: OSErr;	success: Boolean;begin	mainBundle := CFBundleGetMainBundle();	resourcesURL := CFBundleCopyResourcesDirectoryURL(mainBundle);	SetLength(path, PATH_MAX);	success := CFURLGetFileSystemRepresentation(resourcesURL, TRUE, PChar(path), PATH_MAX);	CFRelease(resourcesURL);	if success then	begin		chdir(path);//		WriteLn('Current Path: ', path);	end;end;function LoadPDFPictureResource(fileName: AnsiString): PicHandle;begin// Get file from resource folder.	Home;	result := LoadPDFPicture(fileName);end;function LoadPDFPicture(fileName: AnsiString): PicHandle;var	data: ByteArray;	dataRef: CFMutableDataRef;	provider: CGDataProviderRef;//	dstr: AnsiString;	pdfref: CGPDFDocumentRef;	page: CGPDFPageRef;	pageRect: CGRect;	thePict: PicHandle;begin	data := ReadDataFile(fileName);//	WriteLn('File size = ', Length(data));//	dstr := AnsiString(PChar(@data[0]));//	if Length(dstr) > 10 then SetLength(dstr, 10);//	WriteLn('Data = "', dstr, '"');//	WriteLn('Data = "',  PChar(@data[0]), '"');		dataRef := CFDataCreateMutable(nil, 0);	CFDataAppendBytes(dataRef, @data[0], Length(data));	provider := CGDataProviderCreateWithCFData (dataRef);	pdfref := CGPDFDocumentCreateWithProvider(provider);		page := CGPDFDocumentGetPage (pdfref, 1); { Get first page }	pageRect := CGPDFPageGetBoxRect (page, kCGPDFMediaBox);		if pdfref <> nil then	begin	thePict := New(PicHandle);	thePict^.picFrame := CGRectToRect(pageRect);		thePict^.picImage := nil; // Must be nil	thePict^.picPDF := pdfref; // None yet	thePict^.picPDFDataRef := dataRef; // None yet//	thePict^.picPDFLength := 0; // None yet	LoadPDFPicture := thePict;	end	else		LoadPDFPicture := nil;	//	CFRelease(...);end;procedure SavePDFPictureResource(ph: PicHandle; fileName: AnsiString);begin	Home;	SavePDFPicture(ph, fileName);end;// Pictures! I don't support PICT resources, but load and draw CGImageRef// images with the old calls. PDFs are also supported.// Full replacement of CGContextDrawPDFDocument?// No - scales badly! Why?// CGPDFPageGetDrawingTransform bad? Yes!(*procedure DrawPDFDocumentBAD(c: CGContextRef; rect: CGRect; document: CGPDFDocumentRef; page: SInt32);var	pageRef: CGPDFPageRef;	xf: CGAffineTransform;	cropBox: CGRect;begin	CGContextSaveGState (c);	pageRef := CGPDFDocumentGetPage(document, page);	xf := CGPDFPageGetDrawingTransform(pageRef, kCGPDFMediaBox, rect, 0, 0 {false});	CGContextConcatCTM(c, xf);	cropBox := CGPDFPageGetBoxRect(pageRef, kCGPDFCropBox);	CGContextClipToRect(c, cropBox);	CGContextDrawPDFPage(c, pageRef);	CGContextRestoreGState (c);end;*)// Full replacement for CGContextDrawPDFDocument?// New version without CGPDFPageGetDrawingTransform!// Now it SEEMS to work...procedure DrawPDFDocument(c: CGContextRef; rect: CGRect; document: CGPDFDocumentRef; page: SInt32 );var	pageRef: CGPDFPageRef;//	xf: CGAffineTransform;	cropBox, pageRect: CGRect;	numPages: Longint;begin// Added 20150901: Check for nonexisting pages!	if page < 1 then Exit;	numPages := CGPDFDocumentGetNumberOfPages(document);	if page > numPages then Exit;		CGContextSaveGState (c);	pageRef := CGPDFDocumentGetPage(document, page);	pageRect := CGPDFPageGetBoxRect (pageRef, kCGPDFMediaBox);// Nuke translation before scaling//	CGContextTranslateCTM(c, 0, pageRect.size.height);	CGContextTranslateCTM(c, -pageRect.origin.x, -pageRect.origin.y);	CGContextTranslateCTM(c, rect.origin.x, rect.origin.y);	//	CGContextTranslateCTM(c, originH, originV); // Should be added		CGContextScaleCTM(c, rect.size.width / pageRect.size.width, rect.size.height / pageRect.size.height);//	CGContextTranslateCTM(c, rect.origin.x, -rect.origin.y);	//		WriteLn('Height = ', rect.size.height, pageRect.size.height);//		WriteLn('Width = ', rect.size.width, pageRect.size.width);//		WriteLn('rect.origin = ', rect.origin.x, rect.origin.y);//		WriteLn('pageRect.origin = ', pageRect.origin.x, pageRect.origin.y);// More translate for position of rect?	cropBox := CGPDFPageGetBoxRect(pageRef, kCGPDFCropBox);	CGContextClipToRect(c, cropBox); // cropBox		CGContextDrawPDFPage(c, pageRef);	CGContextRestoreGState (c);end;// Gjorda innan//	CGContextTranslateCTM(thePort^.ctx, originH, originV);//	CGContextRotateCTM(thePort^.ctx, angle/180*Pi);//	CGContextScaleCTM(thePort^.ctx, 1, -1);//	CGContextTranslateCTM(thePort^.ctx, -originH, -originV);// This works nicely. Alas, apple doesn't like CGContextDrawPDFDocument.procedure DrawPDFScaledToFit(document: CGPDFDocumentRef; destRect: Rect; pageNumber: Longint; proportional: Boolean);var	page: CGPDFPageRef;//	portRect: Rect;	portCGRect: CGRect;	pageRect: CGRect;begin	portCGRect := RectToCGRect(destRect);		if proportional then	begin		page := CGPDFDocumentGetPage (document, pageNumber); { Get a page }		pageRect := CGPDFPageGetBoxRect (page, kCGPDFMediaBox);		if portCGRect.size.height / portCGRect.size.width > pageRect.size.height / pageRect.size.width then		// too high			portCGRect.size.height := pageRect.size.height / pageRect.size.width * portCGRect.size.width		else		// too wide			portCGRect.size.width := pageRect.size.width / pageRect.size.height * portCGRect.size.height;	end;	// Must flip or the PDF will be upside-down//	CGContextScaleCTM(thePort^.ctx, 1, -1);//	portCGRect.origin.y := -portCGRect.size.height;	// Draw the page:	DrawPDFDocument (thePort^.ctx, portCGRect, document, pageNumber);// Flip back//	CGContextScaleCTM(thePort^.ctx, 1, -1);end;// Old Picture support, moved from the QDCG main unit, now with support// for the PDF system above.procedure DrawPicture(image: PicHandle; r: Rect); overload;//var//	cgr: CGRect;begin	DrawPicture(image, r, (r.right+r.left)/2, (r.bottom+r.top)/2, 0);//	DrawPicture(image, r, 0, 0, 0);//	cgr := RectToCGRect(r);//	CGContextDrawImage(thePort^.ctx, cgr, image);end;procedure DrawPicture(image: PicHandle; r: Rect; originH, originV: Real; angle: Real; page: Longint);overload;var	cgr: CGRect;begin	if thePort = nil then Exit;	CGContextSaveGState (thePort^.ctx);//	originV := FlipY(originV);// This is not needed any more		CGContextTranslateCTM(thePort^.ctx, originH, originV);	CGContextRotateCTM(thePort^.ctx, angle/180*Pi);	CGContextScaleCTM(thePort^.ctx, 1, -1);	CGContextTranslateCTM(thePort^.ctx, -originH, -originV);		cgr := RectToCGRect(r);//	if image^.picType = 0 then	if image^.picImage <> nil then		CGContextDrawImage(thePort^.ctx, cgr, image^.picImage)	else		DrawPDFDocument (thePort^.ctx, cgr, image^.picPDF, page);//		DrawPDFScaledToFit(image^.picPDFData, r, 0, false);		CGContextRestoreGState (thePort^.ctx);end;// Many variantsprocedure DrawPicture(image: PicHandle; r: Rect; originH, originV: Real; angle: Real);overload;begin	DrawPicture(image, r, originH, originV, angle, 1);end;procedure DrawPicture(image: PicHandle; r: Rect; origin: Point; angle: Real);overload;begin	DrawPicture(image, r, origin.h, origin.v, angle);end;procedure DrawPicture(image: PicHandle; r: Rect; angle: Real);overload;begin	DrawPicture(image, r, (r.left+r.right)/2, (r.top+r.bottom)/2, angle);end;procedure DrawPicture(image: PicHandle; r: Rect; origin: Point; angle: Real; page: Longint);overload;begin	DrawPicture(image, r, origin.h, origin.v, angle, page);end;procedure DrawPicture(image: PicHandle; r: Rect; angle: Real; page: Longint);overload;begin	DrawPicture(image, r, (r.left+r.right)/2, (r.top+r.bottom)/2, angle, page);end;// Variants without Rectprocedure DrawPicture(image: PicHandle; left, top, right, bottom: Real); overload;var	r: Rect;begin	SetRect(r, left, top, right, bottom);	DrawPicture(image, r, (r.right+r.left)/2, (r.bottom+r.top)/2, 0);end;procedure DrawPicture(image: PicHandle; left, top, right, bottom, originH, originV, angle: Real; page: Longint);overload;var	r: Rect;begin	SetRect(r, left, top, right, bottom);	DrawPicture(image, r, originH, originV, angle, page);end;procedure DrawPicture(image: PicHandle; left, top, right, bottom, originH, originV, angle: Real);overload;var	r: Rect;begin	SetRect(r, left, top, right, bottom);	DrawPicture(image, r, originH, originV, angle, 1);end;procedure DrawPicture(image: PicHandle; left, top, right, bottom: Real; origin: Point; angle: Real);overload;var	r: Rect;begin	SetRect(r, left, top, right, bottom);	DrawPicture(image, r, origin.h, origin.v, angle);end;procedure DrawPicture(image: PicHandle; left, top, right, bottom, angle: Real);overload;var	r: Rect;begin	SetRect(r, left, top, right, bottom);	DrawPicture(image, r, (r.left+r.right)/2, (r.top+r.bottom)/2, angle);end;procedure DrawPicture(image: PicHandle; left, top, right, bottom: Real; origin: Point; angle: Real; page: Longint);overload;var	r: Rect;begin	SetRect(r, left, top, right, bottom);	DrawPicture(image, r, origin.h, origin.v, angle, page);end;procedure DrawPicture(image: PicHandle; left, top, right, bottom, angle: Real; page: Longint);overload;var	r: Rect;begin	SetRect(r, left, top, right, bottom);	DrawPicture(image, r, (r.left+r.right)/2, (r.top+r.bottom)/2, angle, page);end;function CountPicturePages(image: PicHandle): Longint;begin	if image^.picImage <> nil then		result := 1	else		result := CGPDFDocumentGetNumberOfPages(image^.picPDF);end;// Copied from TransSkelfunction CFStringToString(input: CFStringRef): AnsiString;var	output: AnsiString;	used: Longint;begin	CFStringGetBytes( input, CFRangeMake(0, CFStringGetLength(input)),			kCFStringEncodingUTF8, Ord('^'), false, nil, CFStringGetLength(input)*2, used);	SetLength(output, used);	CFStringGetBytes( input, CFRangeMake(0, CFStringGetLength(input)),			kCFStringEncodingUTF8, Ord('^'), false, @output[1], CFStringGetLength(input)*2, used);	result := output;end;// Unnecessarily complicated// Bug fixes 100511; was non-ASCII-unfriendly. Still needs simplifyingfunction GetPicture(fileName: AnsiString): PicHandle;var	url: CFURLRef;	provider: CGDataProviderRef;	image: CGImageRef;		pathCFStr: CFStringRef;//	pathCStr: PChar;	pathStr: AnsiString;	suffix: String;	//	i: Longint;	pic: PicHandle;begin// If it is a PDF, use LoadPDFPictureResource.	suffix := Copy(fileName, Length(fileName)-3, 4);	if (suffix = '.pdf') or (suffix = '.PDF') then	begin		result := LoadPDFPictureResource(fileName);		Exit(GetPicture);	end;		if fileName[1] = '/' then // Is it a global path?	begin	end	else	begin // Not global - use the resources folder// Problem #1: Locate the file. Get the path to the bundle:		url := CFBundleCopyBundleURL(CFBundleGetMainBundle);		pathCFStr := CFURLCopyFileSystemPath(url, kCFURLPOSIXPathStyle);		pathStr := CFStringToString(pathCFStr);		CFRelease(pathCFStr);		CFRelease(url);// #2: Concatenate to path to file. At least this is as easy as it should.// A file in "Resources" (included in case that is what you want, and you// should: built-in images should go there):// A file in the Resources folder:		fileName := pathStr + '/Contents/Resources/' + fileName;		WriteLn(fileName);// NOTE: This does not support localized folders!	end;	// #3: Load file. In the old days, you either asked the system to load from// a file specification, or you provided a data buffer. Now, you must allocate// a "DataProvider". In what way that is better is beyond me.//	pathCFStr := CFStringCreateWithBytes(nil, @fileName[1], Length(fileName), kCFStringEncodingMacRoman, false);	pathCFStr := CFStringCreateWithBytes(nil, @fileName[1], Length(fileName), kCFStringEncodingUTF8, false);// This works too://	pathCFStr := CFStringCreateWithCString(nil, PChar(fileName), kCFStringEncodingMacRoman);		url := CFURLCreateWithFileSystemPath(nil, pathCFStr, kCFURLPOSIXPathStyle, false);	if url = nil then WriteLn('No url!');	provider := CGDataProviderCreateWithURL(url);		if (suffix = '.jpg') or (suffix = '.JPG') then		image := CGImageCreateWithJPEGDataProvider(provider, nil, 1, kCGRenderingIntentDefault)	else	if (suffix = '.png') or (suffix = '.PNG') then		image := CGImageCreateWithPNGDataProvider(provider, nil, 1, kCGRenderingIntentDefault)	else	// Assume JPEG		image := CGImageCreateWithJPEGDataProvider(provider, nil, 1, kCGRenderingIntentDefault);		CFRelease(url);	CFRelease(pathCFStr);	CGDataProviderRelease(provider);		if image <> nil then	begin		pic := New(PicHandle);		pic^.picImage := image;		pic^.picPDF := nil; // This is not a PDF		pic^.picPDFDataRef := nil;				SetRect(pic^.picFrame, 0, 0, CGImageGetWidth(image), CGImageGetHeight(image));			//	pic^.picType := 0; // image		result := pic;	end	else		result := nil;end;procedure KillPicture(var image: PicHandle);begin	if image^.picImage <> nil then		CGImageRelease(image^.picImage);	if image^.picPDF <> nil then		CGPDFDocumentRelease(image^.picPDF);	if image^.picPDFDataRef <> nil then		CFRelease(image^.picPDFDataRef);	Dispose(image);	image := nil;end;procedure QDGetPictureBounds(image: PicHandle; var bounds: Rect); overload;begin	bounds.top := 0;	bounds.left := 0;	if image^.picImage <> nil then	begin		bounds.bottom := CGImageGetHeight(image^.picImage);		bounds.right := CGImageGetWidth(image^.picImage);	end	else		bounds := image^.picFrame;end;procedure QDGetPictureBounds(image: PicHandle; var bounds: Point); overload;begin	if image^.picImage <> nil then	begin		bounds.v := CGImageGetHeight(image^.picImage);		bounds.h := CGImageGetWidth(image^.picImage);	end	else		bounds := image^.picFrame.botRight;end;function QDGetPictureBounds(image: PicHandle): Point; overload;begin	if image^.picImage <> nil then	begin		result.v := CGImageGetHeight(image^.picImage);		result.h := CGImageGetWidth(image^.picImage);	end	else		result := image^.picFrame.botRight;end;// ------------- GWorlds ------------procedure DisposeGWorld(offscreenGWorld: GWorldPtr);var	bitmapData: Pointer;begin    bitmapData := CGBitmapContextGetData(offscreenGWorld^.ctx);  // 7    CGContextRelease (offscreenGWorld^.ctx); // 8    if bitmapData <> nil then FreeMem{free}(bitmapData);  // 9    Dispose(offscreenGWorld);end;procedure CopyBits(src, dest: GrafPtr; srcRect, destRect: Rect {+ transfer mode});var	fullImage, subimage: CGImageRef;begin	fullImage := CGBitmapContextCreateImage (src^.ctx); // 5	subImage := CGImageCreateWithImageInRect(fullImage, RectToCGRect(srcRect));	CGContextDrawImage(dest^.ctx, RectToCGRect(destRect), subImage);	CGImageRelease(subImage);	CGImageRelease(fullImage);end;// CopyMask not done yet!function NewGWorld(var offscreenGWorld: GWorldPtr; boundsRect: Rect): OSErr;var    context: CGContextRef = nil;    colorSpace: CGColorSpaceRef;    bitmapData: Pointer;    bitmapByteCount, bitmapBytesPerRow: Longint;    pixelsWide, pixelsHigh: Longint;begin	NewGWorld := 0;	pixelsWide := Trunc(boundsRect.right - boundsRect.left);	pixelsHigh := Trunc(boundsRect.bottom - boundsRect.top);    bitmapBytesPerRow   := (pixelsWide * 4); // 1    bitmapByteCount     := (bitmapBytesPerRow * pixelsHigh);     colorSpace := CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB); // 2//    bitmapData := malloc( bitmapByteCount ); // 3    GetMem(bitmapData, bitmapByteCount);    if bitmapData = nil then    begin        WriteLn('Memory not allocated!');        offscreenGWorld := nil;        NewGWorld := -1;        Exit(NewGWorld);    end;    context := CGBitmapContextCreate (bitmapData, // 4                                    pixelsWide,                                    pixelsHigh,                                    8,      // bits per component                                    bitmapBytesPerRow,                                    colorSpace,                                    kCGImageAlphaPremultipliedLast);    if context = nil then    begin        FreeMem{free} (bitmapData); // 5        WriteLn('Context not created!');        offscreenGWorld := nil;        NewGWorld := -2;        Exit(NewGWorld);    end;		offscreenGWorld := New(GWorldPtr);	offscreenGWorld^.ctx := context;	offscreenGWorld^.height := pixelsHigh;	offscreenGWorld^.portRect := boundsRect; // Offset to 0,0?	offscreenGWorld^.temporaryPort := true; // Should be disposed by DisposeGWorld so this doesn't matter!	    CGColorSpaceRelease( colorSpace ); // 6end;end.