// My own scroll view. Scrolling entirely based on the size of the content view.// 2013-03-25// 2013-08-19: SynchScrollStep makes the scroll steps reasonableunit Scroller;interfaceuses	MacOSAll, TransSkel4, CarbonUtils;type	ScrollData = record		masterView, scrollH, scrollV, peepHoleView, contentView: ControlRef;		theHValue, theVValue: Longint;	end;	ScrollDataPtr = ^ScrollData;function EmbedInScroller(parent: ControlRef; var content: ControlRef; hasVertical, hasHorizontal, resizeContent: Boolean; contentDesiredSize: Rect): ScrollDataPtr;procedure ResizeScroller(theScrollData: ScrollDataPtr; newSize: Rect);implementationconst	kScrollbarWidth = 15;//	kScrollbarBonusWidth = 0;function ScrollbarChanged(theView: HIViewRef; myPtr: Pointer): Boolean;var//	control: ControlRef;//	err: OSErr;	theScrollData: ScrollDataPtr;	h, v, dx, dy, maxx, maxy: Longint;	r, pr: Rect;begin// Order a redraw of the contents!// Translate contents according to scroll bars!//WriteLn('Scrollbar changed');	theScrollData := ScrolldataPtr(myPtr);	h := 0; v := 0; maxx := 1; maxy := 1;	if theScrollData^.scrollH <> nil then	begin		h := GetControl32BitValue (theScrollData^.scrollH);		maxx := GetControlMaximum(theScrollData^.scrollH); // I assume minimum is 0	end;	if theScrollData^.scrollV <> nil then	begin		v := GetControl32BitValue (theScrollData^.scrollV);		maxy := GetControlMaximum(theScrollData^.scrollV);	end;	GetControlBounds(theScrollData^.contentView, r);	GetControlBounds(theScrollData^.peepHoleView, pr);	dx := (r.right-r.left) - (pr.right-pr.left);	dy := (r.bottom-r.top) - (pr.bottom-pr.top);	if dx < 0 then dx := 0;	if dy < 0 then dy := 0;	OffsetRect(r, -r.left, -r.top);	OffsetRect(r, -dx*h div maxx, -dy*v div maxy);	SetControlBounds(theScrollData^.contentView, r);	//	err := VMGetControl(theWind, 'picV', 0, control);	HIViewSetNeedsDisplay(theScrollData^.contentView, true); // or HIViewRender for immediate action//	HIViewSetNeedsDisplay(theScrollData^.masterView, true); // or HIViewRender for immediate actionend;procedure SynchScrollStep(theScrollData: ScrollDataPtr);var//	newViewSize: SInt32;	heightOfPeephole, heightOfContent, widthOfPeephole, widthOfContent: Longint;	r: Rect;begin	// SYNCH CONTROLS	// New: Set view size properly. Or not? Change to scroll bar value in actual pixels?	// Value changes not affected? How can I change that?	GetControlBounds(theScrollData^.peepHoleView, r);	heightOfPeephole := r.bottom - r.top;	widthOfPeephole := r.right - r.left;	GetControlBounds(theScrollData^.contentView, r);	heightOfContent := r.bottom - r.top;	widthOfContent := r.right - r.left;	if theScrollData^.scrollV <> nil then	begin// What should I pass to SetControlViewSize to get a good size?//		SetControlViewSize (theScrollData^.scrollV, ???);		if heightOfContent-heightOfPeephole > 0 then			VMInstallDefaultScrollHandler(theScrollData^.scrollV, 1, 100 * heightOfPeephole div (heightOfContent-heightOfPeephole));	end;	if theScrollData^.scrollH <> nil then	begin		if widthOfContent-widthOfPeephole > 0 then			VMInstallDefaultScrollHandler(theScrollData^.scrollH, 1, 100 * widthOfPeephole div (widthOfContent-widthOfPeephole));	end;end;procedure ResizeScroller(theScrollData: ScrollDataPtr; newSize: Rect);var	r: Rect;begin	SetControlBounds(theScrollData^.masterView, newSize);	// Change to local 	OffsetRect(newSize, -newSize.left, -newSize.top);	r := newSize;	if theScrollData^.scrollV <> nil then r.right -= kScrollbarWidth;	if theScrollData^.scrollH <> nil then r.bottom -= kScrollbarWidth;	SetControlBounds(theScrollData^.peepHoleView, r);//	masterView, scrollH, scrollV, peepHoleView, contentView: ControlRef;	if theScrollData^.scrollV <> nil then	begin		r := newSize;		r.left := r.right - kScrollbarWidth;// Did not help.//		r.right += kScrollbarBonusWidth;//		r.left -= kScrollbarBonusWidth;		if theScrollData^.scrollH <> nil then r.bottom -= kScrollbarWidth;		SetControlBounds(theScrollData^.scrollV, r);	end;	if theScrollData^.scrollH <> nil then	begin		r := newSize;		r.top := r.bottom - kScrollbarWidth;		if theScrollData^.scrollV <> nil then r.right -= kScrollbarWidth;		SetControlBounds(theScrollData^.scrollH, r);	end;	SynchScrollStep(theScrollData);		ScrollbarChanged(nil, theScrollData);end; // ResizeScrollerfunction MasterViewEventHandlerProc(nextHandler: EventHandlerCallRef; inEvent: EventRef; inUserData: Pointer ):OSStatus; MWPascal;var	myViewDataPtr: ScrollDataPtr;		eventClass: UInt32;	eventKind: UInt32;	r: Rect;	wheelDelta: Longint;	axis: EventMouseWheelAxis;	scrollbar: HIViewRef;	max, value: Longint;begin	eventClass := GetEventClass(inEvent);	eventKind  := GetEventKind(inEvent);	myViewDataPtr := ScrollDataPtr(inUserData);		// Standard bye-bye	if eventClass = kEventClassControl then		if eventKind = kEventControlDispose then		begin			DisposePtr(inUserData);		end;	// Resize	if eventClass = kEventClassControl then		if eventKind = kEventControlBoundsChanged then		begin			// Get bounds			GetControlBounds(myViewDataPtr^.masterView, r);			// Call resize			// Change to local //			OffsetRect(r, -r.left, -r.top);			ResizeScroller(myViewDataPtr, r);		end;						if eventClass = kEventClassMouse then		begin		// 150317: Mouse wheel!		if ((eventClass = kEventClassMouse) and (eventKind = kEventMouseWheelMoved)) then		begin			if GetEventParameter(inEvent, kEventParamMouseWheelDelta, typeLongInteger,								nil, sizeof(Longint), nil, @wheelDelta ) = noErr then			begin				// Scroll by wheelDelta!				WriteLn('Wheel ', wheelDelta);								// Scroll the active view!				begin						WriteLn('Wheel applied!');						GetEventParameter(inEvent, kEventParamMouseWheelAxis, typeMouseWheelAxis,									nil, sizeof(EventMouseWheelAxis), nil, @axis);						if axis = kEventMouseWheelAxisY then							scrollbar := myViewDataPtr^.scrollV						else							scrollbar := myViewDataPtr^.scrollH;						if scrollbar <> nil then						begin							value := VMGetNumValue(scrollbar) - wheelDelta;							max := GetControl32BitMaximum(scrollbar);							if value <= max then								VMSetNumValue(scrollbar, value);						end;											end				end;			end		end;	MasterViewEventHandlerProc := noErr;end;// Get a view, create a new view with scrollbarsfunction EmbedInScroller(parent: ControlRef; var content: ControlRef; hasVertical, hasHorizontal, resizeContent: Boolean; contentDesiredSize: Rect): ScrollDataPtr;var	r: Rect;//	err: OSErr;	myScrollData: ScrollDataPtr;	mainFrame: Rect;	layout: HILayoutInfo;			viewEvents: array [0..2] of EventTypeSpec =	(		( eventClass: kEventClassControl; eventKind: kEventControlBoundsChanged ), // FŒngar resize		( eventClass: kEventClassControl; eventKind: kEventControlDispose ),		( eventClass: kEventClassMouse; eventKind: kEventMouseWheelMoved )	);begin	myScrollData := ScrollDataPtr(NewPtr(SizeOf(ScrollData))); // masterView, scrollH, scrollV, peepHoleView, contentView: ControlRef;	if parent = nil then		parent := HIViewGetSuperview(content);	GetControlBounds(content, mainFrame);// Detach!	layout.version := kHILayoutInfoVersionZero;	HIViewGetLayoutInfo (content, layout); // Get layout	myScrollData^.contentView := content;	HIViewRemoveFromSuperview(content);// Make a main view as parent for the rest//	SetRect(mainFrame, 0, 0, 400, 400);	CreateUserPaneControl(nil, mainFrame, kControlSupportsEmbedding, myScrollData^.masterView); // Top view, connects to parent	HIViewSetLayoutInfo (myScrollData^.masterView, layout); // Put back layout		// Change to local //	OffsetRect(mainFrame, -mainFrame.left, -mainFrame.top);// Make a peephole view	r := mainFrame;	if hasVertical then r.right -= kScrollbarWidth;	if hasHorizontal then r.bottom -= kScrollbarWidth;	CreateUserPaneControl(nil, r, kControlSupportsEmbedding, myScrollData^.peepHoleView); // feature: kControlSupportsEmbedding	HIViewAddSubview (parent, myScrollData^.masterView);	HIViewAddSubview (myScrollData^.masterView, myScrollData^.peepHoleView);	HIViewAddSubview (myScrollData^.peepHoleView, myScrollData^.contentView);	// We won't use the "content" variable again. Pass the masterView back to caller using it.	content := myScrollData^.masterView;// Make new scroll bars	if hasVertical then	begin		r := mainFrame;//		r.left := r.right - kScrollbarWidth;//		if hasHorizontal then r.bottom -= kScrollbarWidth;		CreateScrollBarControl(nil, r, 0, 0, 100, 0{*}, true, nil, myScrollData^.scrollV);		HIViewAddSubview (myScrollData^.masterView, myScrollData^.scrollV);		HIViewSetVisible(myScrollData^.scrollV, true);	end	else		myScrollData^.scrollV := nil;	if hasHorizontal then	begin		r := mainFrame;//		r.top := r.bottom - kScrollbarWidth;//		if hasVertical then r.right -= kScrollbarWidth;		CreateScrollBarControl(nil, r, 0, 0, 100, 0, true, nil, myScrollData^.scrollH);		HIViewAddSubview (myScrollData^.masterView, myScrollData^.scrollH);		HIViewSetVisible(myScrollData^.scrollH, true);	end	else		myScrollData^.scrollH := nil;	if hasHorizontal then InstallViewHandlerByRef(nil, myScrollData^.scrollH, kViewDataCustom, myScrollData, @ScrollbarChanged, nil);	if hasVertical then InstallViewHandlerByRef(nil, myScrollData^.scrollV, kViewDataCustom, myScrollData, @ScrollbarChanged, nil);	if hasHorizontal then VMInstallDefaultScrollHandler(myScrollData^.scrollH, 1, 10);	if hasVertical then VMInstallDefaultScrollHandler(myScrollData^.scrollV, 1, 10);	if resizeContent then		SetControlBounds(myScrollData^.contentView, contentDesiredSize);	ResizeScroller(myScrollData, mainFrame); // incl ScrollbarChanged and SyncScrollStep	// Handler for master view	InstallEventHandler( GetControlEventTarget(myScrollData^.masterView), @MasterViewEventHandlerProc, Length(viewEvents), viewEvents, myScrollData, nil );	EmbedInScroller := myScrollData;end; // EmbedInScroller// Trivialprocedure ResizeScrollerContent(myScrollData: ScrollDataPtr; r: Rect);begin	SetControlBounds(myScrollData^.contentView, r);end;// Create window with scroller and built-in resizing?// Extend TransSkel with ability to resize views in window properly?end.